# @openclaw/dojo-genesis v1.0.0: The Orchestration Engine

**Author:** Cruz + Claude (Cowork)
**Status:** Final
**Created:** 2026-02-12
**Grounded In:** ARCHITECTURE.md v0.4.0, Strategic Scout (Gateway UI), 10 resolved architectural questions, OpenClaw Plugin SDK research

---

## 1. Vision

> Turn OpenClaw into a specification-driven development studio where projects move through scouting, specification, decomposition, commission, and retrospective — with persistent state, real documents, and 44 behavioral skills.

**The Core Insight:**

OpenClaw already owns the hardest parts of the agent platform: multi-channel routing, skill loading, plugin lifecycle, and distribution to millions of users via ClawHub. What it lacks is *workflow memory*. Each conversation is stateless. There is no concept of a "project" that persists across sessions, accumulates decisions, and guides a team through a structured development methodology.

Dojo Genesis adds the orchestration layer. It introduces projects as first-class entities with phases, tracks, decisions, and artifacts. It wraps 44 proven behavioral skills — already battle-tested in the Dojo Genesis desktop shell — inside a project-aware orchestration framework. The result is a plugin that turns any OpenClaw channel into a development command center.

**What Makes This Different:**

This is not a chatbot that gives advice about development. It is a state machine that *does* development orchestration. `/dojo init mobile-redesign` creates a project with a persistent state file. `/dojo scout "should we build native or PWA"` runs a strategic scout, saves the output as a markdown document, and advances the project phase. The workflow produces real files — specifications, implementation prompts, retrospectives — that exist on disk after the conversation ends.

The progressive enhancement model means this works everywhere OpenClaw runs. A user on WhatsApp gets the full orchestration experience via markdown in chat. A user on WebChat with Canvas gets an interactive dashboard on top. The floor is high; the ceiling is higher.

## 2. Goals and Success Criteria

**Primary Goals:**

1. Ship a functional OpenClaw plugin that registers `/dojo` commands, 3 orchestration tools, and 5 core skills
2. Implement persistent project state management with file-based storage at `~/.openclaw/dojo-genesis/`
3. Produce real markdown artifacts (scouts, specs, prompts, retros) saved to project directories
4. Maintain dual-mode operation: skills work standalone AND inside project orchestration

**Success Criteria:**

- A user can run the full workflow: `init` -> `scout` -> `spec` -> `tracks` -> `commission` -> `retro` and find all outputs as files on disk
- All 5 auto-reply commands (`init`, `switch`, `status`, `list`, `archive`) return well-formatted markdown in under 200ms
- All 5 skill-invoking commands (`scout`, `spec`, `tracks`, `commission`, `retro`) correctly set project context via `shouldContinue` + `updatedCtx`
- The 3 orchestration tools (`dojo_get_context`, `dojo_save_artifact`, `dojo_update_state`) are registered and callable by the agent
- Skills produce identical quality output in standalone mode and orchestration mode
- Plugin passes `openclaw skill validate` for all bundled skills
- Plugin installs cleanly via `openclaw plugins install @openclaw/dojo-genesis`

**Non-Goals (Out of Scope for v1.0.0):**

- Canvas / A2UI visual dashboard (deferred to v1.1.0 — architecture specified, not built)
- Porting all 44 skills (v1.0.0 ships 8 core skills; remaining 36 in v1.0.x batches)
- Multi-user collaboration on the same project
- Cloud sync or remote state storage
- Integration with external issue trackers (GitHub Issues, Jira, etc.)

---

## 3. Technical Architecture

### 3.1 System Overview

The plugin integrates with OpenClaw as a TypeScript extension registered through `openclaw.extensions`. It adds project orchestration on top of OpenClaw's existing skill loading, prompt injection, and multi-channel routing.

```
User ──→ /dojo scout "tension X"
           │
           ▼
┌─────────────────────────────────┐
│  OpenClaw Gateway               │
│                                 │
│  Command Router                 │
│    └── /dojo handler            │
│         ├── init, switch, ...   │ ← shouldContinue: false (auto-reply)
│         └── scout, spec, ...    │ ← shouldContinue: true + updatedCtx
│                                 │
│  Agent Turn                     │
│    ├── System Prompt            │
│    │     └── Skill XML Block    │ ← SKILL.md injected by OpenClaw
│    ├── Message Context          │
│    │     └── dojoProject,       │ ← updatedCtx from command handler
│    │         dojoPhase           │
│    └── Tool Calls               │
│          ├── dojo_get_context   │ ← Full project state
│          ├── dojo_save_artifact │ ← Write file to project dir
│          └── dojo_update_state  │ ← Advance phase, record skill
│                                 │
│  Hooks                          │
│    ├── on-skill-complete        │ ← Auto-save + state update
│    └── on-phase-change          │ ← Update PROJECT.md
└─────────────────────────────────┘
           │
           ▼
~/.openclaw/dojo-genesis/
├── global-state.json
└── projects/{name}/
    ├── state.json
    ├── PROJECT.md
    ├── scouts/*.md
    ├── specs/*.md
    ├── prompts/*.md
    ├── retros/*.md
    └── decisions.md
```

**Key Components:**

1. **Command System** — Registers `/dojo` with 10 subcommands. 5 auto-reply (deterministic, no agent). 5 skill-invoking (pass context, continue to agent).
2. **State Manager** — Singleton `DojoStateManager` with write-through cache. Reads from disk on first access. Writes update cache and disk atomically.
3. **Orchestration Tools** — 3 tools registered via `api.registerTool()`. Agent calls these during skill execution to read context, save files, and update state.
4. **Plugin Hooks** — 2 event-driven hooks: `on-skill-complete` (auto-save artifact, record activity) and `on-phase-change` (update PROJECT.md).
5. **Skill System** — 8 core SKILL.md files with orchestration integration sections. Dual-mode: standalone (no project) or orchestrated (project-aware).

### 3.2 Plugin Scaffold — Directory Layout

```
@openclaw/dojo-genesis/
├── package.json
├── tsconfig.json
├── index.ts
├── src/
│   ├── commands/
│   │   ├── router.ts
│   │   ├── init.ts
│   │   ├── switch.ts
│   │   ├── status.ts
│   │   ├── list.ts
│   │   └── archive.ts
│   ├── state/
│   │   ├── manager.ts
│   │   ├── types.ts
│   │   └── migrations.ts
│   ├── orchestration/
│   │   ├── context-provider.ts
│   │   ├── artifact-saver.ts
│   │   ├── state-updater.ts
│   │   └── tool-registry.ts
│   ├── hooks/
│   │   ├── on-skill-complete.ts
│   │   └── on-phase-change.ts
│   ├── ui/
│   │   └── chat-formatter.ts
│   └── utils/
│       ├── validation.ts
│       ├── file-ops.ts
│       └── markdown.ts
├── hooks/
│   ├── on-skill-complete/
│   │   ├── HOOK.md
│   │   └── handler.ts
│   └── on-project-phase-change/
│       ├── HOOK.md
│       └── handler.ts
├── skills/
│   ├── strategic-scout/SKILL.md
│   ├── release-specification/SKILL.md
│   ├── parallel-tracks/SKILL.md
│   ├── implementation-prompt/SKILL.md
│   ├── retrospective/SKILL.md
│   ├── context-ingestion/SKILL.md
│   ├── pre-implementation-checklist/SKILL.md
│   └── handoff-protocol/SKILL.md
├── tests/
│   ├── commands/
│   │   ├── router.test.ts
│   │   ├── init.test.ts
│   │   ├── status.test.ts
│   │   └── list.test.ts
│   ├── state/
│   │   └── manager.test.ts
│   ├── orchestration/
│   │   ├── context-provider.test.ts
│   │   ├── artifact-saver.test.ts
│   │   └── state-updater.test.ts
│   ├── hooks/
│   │   └── on-skill-complete.test.ts
│   └── e2e/
│       └── full-workflow.test.ts
└── README.md
```

### 3.3 State Management — Detailed Design

**Purpose:** Persist project state across sessions. Every `/dojo` interaction reads from and writes to the file system. The `DojoStateManager` singleton ensures consistent access with a write-through cache.

**TypeScript Interfaces:**

```typescript
// src/state/types.ts

export type DojoPhase =
  | "initialized"
  | "scouting"
  | "specifying"
  | "decomposing"
  | "commissioning"
  | "implementing"
  | "retrospective";

export interface GlobalState {
  version: string;               // Schema version for migrations
  activeProjectId: string | null;
  projects: ProjectMetadata[];
  lastUpdated: string;           // ISO 8601
}

export interface ProjectMetadata {
  id: string;                    // URL-safe slug: /^[a-z0-9][a-z0-9-]{1,63}$/
  name: string;                  // Display name
  description: string;
  phase: DojoPhase;
  createdAt: string;
  lastAccessedAt: string;
  archived: boolean;
}

export interface ProjectState {
  projectId: string;
  phase: DojoPhase;
  tracks: Track[];
  decisions: DecisionRef[];
  specs: SpecRef[];
  artifacts: ArtifactRef[];
  currentTrack: string | null;
  lastSkill: string;
  activityLog: ActivityEntry[];  // Last 50 entries
  lastUpdated: string;
}

export interface Track {
  id: string;                    // "track-a", "track-1", etc.
  name: string;
  status: "pending" | "in-progress" | "completed" | "blocked";
  dependencies: string[];        // Track IDs this depends on
  promptFile: string | null;     // Path to implementation prompt
}

export interface DecisionRef {
  date: string;
  topic: string;
  file: string;                  // Relative path within project dir
}

export interface SpecRef {
  version: string;
  file: string;
}

export interface ArtifactRef {
  category: string;              // "scouts", "specs", "prompts", "retros"
  filename: string;
  createdAt: string;
  skill: string;                 // Which skill produced this
}

export interface ActivityEntry {
  timestamp: string;
  action: string;                // "skill:strategic-scout", "command:init", etc.
  summary: string;               // One-line description
}
```

**DojoStateManager Implementation:**

```typescript
// src/state/manager.ts

import { readJsonFile, writeJsonFile, ensureDir } from "../utils/file-ops";
import type { GlobalState, ProjectState, ProjectMetadata, DojoPhase } from "./types";

const SCHEMA_VERSION = "1.0.0";
const MAX_ACTIVITY_LOG = 50;

export class DojoStateManager {
  private basePath: string;
  private globalCache: GlobalState | null = null;
  private projectCache: Map<string, ProjectState> = new Map();

  constructor(configDir: string) {
    this.basePath = `${configDir}/dojo-genesis`;
  }

  // --- Global State ---

  async getGlobalState(): Promise<GlobalState> {
    if (!this.globalCache) {
      await ensureDir(this.basePath);
      this.globalCache = await readJsonFile<GlobalState>(
        `${this.basePath}/global-state.json`,
        { version: SCHEMA_VERSION, activeProjectId: null, projects: [], lastUpdated: new Date().toISOString() }
      );
    }
    return this.globalCache;
  }

  async setActiveProject(projectId: string | null): Promise<void> {
    const state = await this.getGlobalState();
    state.activeProjectId = projectId;
    state.lastUpdated = new Date().toISOString();
    if (projectId) {
      const meta = state.projects.find(p => p.id === projectId);
      if (meta) meta.lastAccessedAt = state.lastUpdated;
    }
    await this.saveGlobalState(state);
  }

  async addProject(meta: ProjectMetadata): Promise<void> {
    const state = await this.getGlobalState();
    state.projects.push(meta);
    state.activeProjectId = meta.id;
    state.lastUpdated = new Date().toISOString();
    await this.saveGlobalState(state);
  }

  // --- Project State ---

  async getProjectState(projectId?: string): Promise<ProjectState | null> {
    const global = await this.getGlobalState();
    const id = projectId || global.activeProjectId;
    if (!id) return null;

    if (!this.projectCache.has(id)) {
      const state = await readJsonFile<ProjectState | null>(
        `${this.basePath}/projects/${id}/state.json`,
        null
      );
      if (state) this.projectCache.set(id, state);
      return state;
    }
    return this.projectCache.get(id) || null;
  }

  async updateProjectState(projectId: string, update: Partial<ProjectState>): Promise<void> {
    const current = await this.getProjectState(projectId);
    if (!current) throw new Error(`Project not found: ${projectId}`);

    const updated: ProjectState = {
      ...current,
      ...update,
      lastUpdated: new Date().toISOString(),
    };
    await writeJsonFile(`${this.basePath}/projects/${projectId}/state.json`, updated);
    this.projectCache.set(projectId, updated);

    // Also update metadata in global state
    const global = await this.getGlobalState();
    const meta = global.projects.find(p => p.id === projectId);
    if (meta) {
      meta.phase = updated.phase;
      meta.lastAccessedAt = updated.lastUpdated;
      await this.saveGlobalState(global);
    }
  }

  async addActivity(projectId: string, action: string, summary: string): Promise<void> {
    const state = await this.getProjectState(projectId);
    if (!state) return;

    state.activityLog = [
      { timestamp: new Date().toISOString(), action, summary },
      ...state.activityLog.slice(0, MAX_ACTIVITY_LOG - 1),
    ];
    await this.updateProjectState(projectId, { activityLog: state.activityLog });
  }

  // --- Internal ---

  private async saveGlobalState(state: GlobalState): Promise<void> {
    await writeJsonFile(`${this.basePath}/global-state.json`, state);
    this.globalCache = state;
  }
}

// Module-level singleton — initialized in plugin register()
export let stateManager: DojoStateManager;

export function initStateManager(configDir: string): void {
  stateManager = new DojoStateManager(configDir);
}
```

**File Operations Utilities:**

```typescript
// src/utils/file-ops.ts

import { promises as fs } from "fs";
import { dirname } from "path";

export async function readJsonFile<T>(path: string, defaultValue: T): Promise<T> {
  try {
    const raw = await fs.readFile(path, "utf-8");
    return JSON.parse(raw) as T;
  } catch (err: any) {
    if (err.code === "ENOENT") return defaultValue;
    throw err;
  }
}

export async function writeJsonFile(path: string, data: unknown): Promise<void> {
  await ensureDir(dirname(path));
  const tmp = `${path}.tmp`;
  await fs.writeFile(tmp, JSON.stringify(data, null, 2), "utf-8");
  await fs.rename(tmp, path); // Atomic write
}

export async function writeTextFile(path: string, content: string): Promise<void> {
  await ensureDir(dirname(path));
  const tmp = `${path}.tmp`;
  await fs.writeFile(tmp, content, "utf-8");
  await fs.rename(tmp, path);
}

export async function ensureDir(dir: string): Promise<void> {
  await fs.mkdir(dir, { recursive: true });
}

export async function fileExists(path: string): Promise<boolean> {
  try {
    await fs.access(path);
    return true;
  } catch {
    return false;
  }
}
```

**Input Validation:**

```typescript
// src/utils/validation.ts

const PROJECT_NAME_REGEX = /^[a-z0-9][a-z0-9-]{1,63}$/;
const DOUBLE_HYPHEN = /--/;

export function validateProjectName(name: string): { valid: boolean; error?: string } {
  if (!name) return { valid: false, error: "Project name is required" };
  if (!PROJECT_NAME_REGEX.test(name)) {
    return { valid: false, error: "Project name must be 2-64 chars, lowercase alphanumeric + hyphens, start with letter/number" };
  }
  if (DOUBLE_HYPHEN.test(name)) {
    return { valid: false, error: "Project name cannot contain consecutive hyphens" };
  }
  return { valid: true };
}

export function sanitizeFilename(input: string): string {
  return input
    .toLowerCase()
    .replace(/[^a-z0-9-_]/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-|-$/g, "")
    .slice(0, 128);
}

export function validateOutputDir(dir: string): boolean {
  const allowed = ["scouts", "specs", "prompts", "retros", "artifacts", "tracks"];
  return allowed.includes(dir);
}
```

### 3.4 Command System — Detailed Design

**Purpose:** Register `/dojo` with 10 subcommands. 5 are auto-reply (deterministic). 5 pass context to the agent for skill execution.

**Command Router:**

```typescript
// src/commands/router.ts

import type { PluginAPI, CommandContext, CommandResult } from "openclaw/plugin-sdk";
import { handleInit } from "./init";
import { handleSwitch } from "./switch";
import { handleStatus } from "./status";
import { handleList } from "./list";
import { handleArchive } from "./archive";
import { stateManager } from "../state/manager";

export function registerDojoCommands(api: PluginAPI): void {
  api.registerCommand({
    name: "dojo",
    description: "Dojo Genesis: specification-driven development orchestration",
    acceptsArgs: true,
    requireAuth: true,
    handler: async (ctx: CommandContext): Promise<CommandResult> => {
      const subcommand = ctx.args[0]?.toLowerCase();

      switch (subcommand) {
        // --- Auto-reply commands (shouldContinue: false) ---
        case "init":
          return handleInit(ctx);
        case "switch":
          return handleSwitch(ctx);
        case "status":
          return handleStatus(ctx);
        case "list":
          return handleList(ctx);
        case "archive":
          return handleArchive(ctx);

        // --- Skill-invoking commands (shouldContinue: true) ---
        case "scout":
        case "spec":
        case "tracks":
        case "commission":
        case "retro": {
          const project = await resolveTargetProject(ctx);
          if (!project) {
            return {
              shouldContinue: false,
              reply: { text: "No active project. Run `/dojo init <name>` first." },
            };
          }
          return {
            shouldContinue: true,
            updatedCtx: {
              dojoProject: project.id,
              dojoPhase: project.phase,
              dojoSubcommand: subcommand,
            },
          };
        }

        // --- Help / unknown ---
        case "help":
        case undefined:
          return { shouldContinue: false, reply: { text: HELP_TEXT } };
        default:
          return {
            shouldContinue: false,
            reply: { text: `Unknown command: \`${subcommand}\`. Run \`/dojo help\` for available commands.` },
          };
      }
    },
  });
}

async function resolveTargetProject(ctx: CommandContext) {
  // Check for explicit @project-name in args
  const atProject = ctx.args.find(a => a.startsWith("@"));
  if (atProject) {
    const projectId = atProject.slice(1);
    return stateManager.getProjectState(projectId)
      ? { id: projectId, phase: (await stateManager.getProjectState(projectId))!.phase }
      : null;
  }
  // Fall back to active project
  const global = await stateManager.getGlobalState();
  if (!global.activeProjectId) return null;
  const state = await stateManager.getProjectState(global.activeProjectId);
  return state ? { id: state.projectId, phase: state.phase } : null;
}

const HELP_TEXT = `**Dojo Genesis** — Specification-driven development orchestration

**Project Management:**
\`/dojo init <name>\` — Create a new project
\`/dojo switch <name>\` — Switch active project
\`/dojo status\` — Show current project status
\`/dojo list\` — List all projects
\`/dojo archive <name>\` — Archive a project

**Workflow:**
\`/dojo scout <tension>\` — Run a strategic scout
\`/dojo spec <feature>\` — Write a release specification
\`/dojo tracks\` — Decompose into parallel tracks
\`/dojo commission\` — Generate implementation prompts
\`/dojo retro\` — Run a retrospective

Use \`@project-name\` to target a specific project.`;
```

**Init Command (representative auto-reply handler):**

```typescript
// src/commands/init.ts

import type { CommandContext, CommandResult } from "openclaw/plugin-sdk";
import { stateManager } from "../state/manager";
import { validateProjectName } from "../utils/validation";
import { writeTextFile, ensureDir } from "../utils/file-ops";
import type { ProjectMetadata, ProjectState } from "../state/types";

export async function handleInit(ctx: CommandContext): Promise<CommandResult> {
  const name = ctx.args[1];
  const validation = validateProjectName(name);
  if (!validation.valid) {
    return { shouldContinue: false, reply: { text: `Invalid project name: ${validation.error}` } };
  }

  // Check for duplicate
  const global = await stateManager.getGlobalState();
  if (global.projects.some(p => p.id === name && !p.archived)) {
    return { shouldContinue: false, reply: { text: `Project \`${name}\` already exists. Use \`/dojo switch ${name}\` to activate it.` } };
  }

  // Parse optional --desc flag
  const descIdx = ctx.args.indexOf("--desc");
  const description = descIdx >= 0 ? ctx.args.slice(descIdx + 1).join(" ").replace(/^"|"$/g, "") : "";

  const now = new Date().toISOString();

  // Create project metadata
  const meta: ProjectMetadata = {
    id: name,
    name,
    description,
    phase: "initialized",
    createdAt: now,
    lastAccessedAt: now,
    archived: false,
  };

  // Create project state
  const state: ProjectState = {
    projectId: name,
    phase: "initialized",
    tracks: [],
    decisions: [],
    specs: [],
    artifacts: [],
    currentTrack: null,
    lastSkill: "",
    activityLog: [{ timestamp: now, action: "command:init", summary: `Project created` }],
    lastUpdated: now,
  };

  // Write to file system
  const projectDir = `${stateManager["basePath"]}/projects/${name}`;
  await ensureDir(projectDir);
  await ensureDir(`${projectDir}/scouts`);
  await ensureDir(`${projectDir}/specs`);
  await ensureDir(`${projectDir}/prompts`);
  await ensureDir(`${projectDir}/retros`);
  await ensureDir(`${projectDir}/tracks`);
  await ensureDir(`${projectDir}/artifacts`);

  // Write PROJECT.md
  const projectMd = `# ${name}\n\n${description ? description + "\n\n" : ""}**Phase:** initialized\n**Created:** ${now.split("T")[0]}\n\n---\n\n## Activity Log\n\n- ${now.split("T")[0]} — Project created\n`;
  await writeTextFile(`${projectDir}/PROJECT.md`, projectMd);

  // Write decisions.md (append-only log)
  await writeTextFile(`${projectDir}/decisions.md`, `# Decision Log: ${name}\n\n---\n\n`);

  // Persist state
  await stateManager.addProject(meta);
  await stateManager.updateProjectState(name, state);

  return {
    shouldContinue: false,
    reply: {
      text: `**Project created:** \`${name}\`\n\n**Phase:** initialized\n**Active:** yes\n\nNext: Run \`/dojo scout <tension>\` to start scouting.`,
    },
  };
}
```

**Status Command (chat output formatting — Surface 1):**

```typescript
// src/commands/status.ts

import type { CommandContext, CommandResult } from "openclaw/plugin-sdk";
import { stateManager } from "../state/manager";
import { formatPhase, formatDate, formatTrackTable } from "../ui/chat-formatter";

export async function handleStatus(ctx: CommandContext): Promise<CommandResult> {
  const atProject = ctx.args.find(a => a.startsWith("@"));
  const projectId = atProject?.slice(1) || undefined;
  const state = await stateManager.getProjectState(projectId);

  if (!state) {
    return {
      shouldContinue: false,
      reply: { text: "No active project. Run `/dojo init <name>` to create one." },
    };
  }

  const recentActivity = state.activityLog.slice(0, 5);
  const nextAction = suggestNextAction(state.phase);

  let output = `**Project:** \`${state.projectId}\`\n`;
  output += `**Phase:** ${formatPhase(state.phase)}\n`;
  output += `**Last updated:** ${formatDate(state.lastUpdated)}\n\n`;

  if (state.tracks.length > 0) {
    output += `**Tracks:**\n${formatTrackTable(state.tracks)}\n\n`;
  }

  if (recentActivity.length > 0) {
    output += `**Recent activity:**\n`;
    for (const entry of recentActivity) {
      output += `- ${formatDate(entry.timestamp)} — ${entry.summary}\n`;
    }
    output += "\n";
  }

  if (nextAction) {
    output += `**Suggested next:** ${nextAction}`;
  }

  return { shouldContinue: false, reply: { text: output } };
}

function suggestNextAction(phase: string): string {
  const suggestions: Record<string, string> = {
    initialized: "`/dojo scout <tension>` — Start with a strategic scout",
    scouting: "`/dojo spec <feature>` — Write a release specification",
    specifying: "`/dojo tracks` — Decompose into parallel tracks",
    decomposing: "`/dojo commission` — Generate implementation prompts",
    commissioning: "Hand off prompts to implementation agents",
    implementing: "`/dojo retro` — Run a retrospective when done",
    retrospective: "`/dojo init <name>` — Start a new project, or continue iterating",
  };
  return suggestions[phase] || "";
}
```

**Chat Formatter (Surface 1 output):**

```typescript
// src/ui/chat-formatter.ts

import type { Track, DojoPhase } from "../state/types";

const PHASE_EMOJI: Record<DojoPhase, string> = {
  initialized: "[ ]",
  scouting: "[~]",
  specifying: "[~]",
  decomposing: "[~]",
  commissioning: "[~]",
  implementing: "[>]",
  retrospective: "[*]",
};

export function formatPhase(phase: DojoPhase): string {
  return `${PHASE_EMOJI[phase] || "[ ]"} ${phase}`;
}

export function formatDate(iso: string): string {
  return iso.split("T")[0];
}

export function formatTrackTable(tracks: Track[]): string {
  if (tracks.length === 0) return "_No tracks defined._";

  let table = "| Track | Name | Status | Dependencies |\n";
  table += "|-------|------|--------|-------------|\n";
  for (const t of tracks) {
    const deps = t.dependencies.length > 0 ? t.dependencies.join(", ") : "none";
    table += `| ${t.id} | ${t.name} | ${t.status} | ${deps} |\n`;
  }
  return table;
}

export function formatProjectList(
  projects: Array<{ id: string; phase: string; lastAccessedAt: string; archived: boolean }>,
  showArchived: boolean,
  activeId: string | null,
): string {
  const visible = projects.filter(p => showArchived || !p.archived);
  if (visible.length === 0) return "_No projects. Run `/dojo init <name>` to create one._";

  let table = "| Project | Phase | Last Active | Active |\n";
  table += "|---------|-------|-------------|--------|\n";
  for (const p of visible) {
    const active = p.id === activeId ? ">>>" : "";
    table += `| ${p.id} | ${p.phase} | ${formatDate(p.lastAccessedAt)} | ${active} |\n`;
  }
  return table;
}
```

### 3.5 Orchestration Tools — Detailed Design

**Purpose:** 3 tools registered via `api.registerTool()` that the agent calls during skill execution to interact with project state.

```typescript
// src/orchestration/tool-registry.ts

import type { PluginAPI } from "openclaw/plugin-sdk";
import { Type } from "openclaw/plugin-sdk"; // TypeBox schema builder
import { stateManager } from "../state/manager";
import { validateOutputDir, sanitizeFilename } from "../utils/validation";
import { writeTextFile, ensureDir } from "../utils/file-ops";

export function registerOrchestrationTools(api: PluginAPI): void {

  // --- Tool 1: dojo_get_context ---
  api.registerTool({
    name: "dojo_get_context",
    description: "Get the active Dojo Genesis project context including phase, tracks, decisions, and recent activity. Call this at the start of any skill execution to check if a project is active.",
    parameters: Type.Object({
      projectId: Type.Optional(Type.String({ description: "Target a specific project instead of the active one" })),
    }),
    async execute(_id, params) {
      const state = await stateManager.getProjectState(params.projectId);
      if (!state) {
        return {
          content: [{ type: "text", text: JSON.stringify({ active: false, message: "No active project" }) }],
        };
      }

      // Return full context for the agent
      return {
        content: [{
          type: "text",
          text: JSON.stringify({
            active: true,
            projectId: state.projectId,
            phase: state.phase,
            tracks: state.tracks,
            decisions: state.decisions.map(d => ({ date: d.date, topic: d.topic })),
            specs: state.specs,
            currentTrack: state.currentTrack,
            lastSkill: state.lastSkill,
            recentActivity: state.activityLog.slice(0, 10),
          }),
        }],
      };
    },
  });

  // --- Tool 2: dojo_save_artifact ---
  api.registerTool({
    name: "dojo_save_artifact",
    description: "Save a skill output as a markdown file in the active project directory. Use this after completing a skill to persist the results.",
    parameters: Type.Object({
      filename: Type.String({ description: "Output filename (e.g., '2026-02-12_scout_build-native.md')" }),
      content: Type.String({ description: "Full markdown content to save" }),
      outputDir: Type.String({ description: "Subdirectory: scouts, specs, prompts, retros, tracks, or artifacts" }),
      projectId: Type.Optional(Type.String({ description: "Target specific project" })),
    }),
    async execute(_id, params) {
      if (!validateOutputDir(params.outputDir)) {
        return {
          content: [{ type: "text", text: JSON.stringify({ error: `Invalid output directory: ${params.outputDir}` }) }],
        };
      }

      const global = await stateManager.getGlobalState();
      const id = params.projectId || global.activeProjectId;
      if (!id) {
        return {
          content: [{ type: "text", text: JSON.stringify({ error: "No active project" }) }],
        };
      }

      const safeName = sanitizeFilename(params.filename);
      const dir = `${stateManager["basePath"]}/projects/${id}/${params.outputDir}`;
      const filePath = `${dir}/${safeName}`;

      await ensureDir(dir);
      await writeTextFile(filePath, params.content);

      // Record artifact in project state
      const state = await stateManager.getProjectState(id);
      if (state) {
        state.artifacts.push({
          category: params.outputDir,
          filename: safeName,
          createdAt: new Date().toISOString(),
          skill: state.lastSkill || "unknown",
        });
        await stateManager.updateProjectState(id, { artifacts: state.artifacts });
        await stateManager.addActivity(id, `artifact:${params.outputDir}`, `Saved ${safeName} to ${params.outputDir}/`);
      }

      return {
        content: [{ type: "text", text: JSON.stringify({ saved: true, path: `${params.outputDir}/${safeName}` }) }],
      };
    },
  });

  // --- Tool 3: dojo_update_state ---
  api.registerTool({
    name: "dojo_update_state",
    description: "Update the active project's phase, track status, or other state. Use this after completing a skill to advance the project workflow.",
    parameters: Type.Object({
      phase: Type.Optional(Type.String({ description: "New project phase (initialized, scouting, specifying, decomposing, commissioning, implementing, retrospective)" })),
      lastSkill: Type.Optional(Type.String({ description: "Name of the skill that just ran" })),
      currentTrack: Type.Optional(Type.String({ description: "Set the current active track" })),
      addTrack: Type.Optional(Type.Object({
        id: Type.String(),
        name: Type.String(),
        dependencies: Type.Optional(Type.Array(Type.String())),
      })),
      addDecision: Type.Optional(Type.Object({
        topic: Type.String(),
        file: Type.String(),
      })),
      addSpec: Type.Optional(Type.Object({
        version: Type.String(),
        file: Type.String(),
      })),
      projectId: Type.Optional(Type.String({ description: "Target specific project" })),
    }),
    async execute(_id, params) {
      const global = await stateManager.getGlobalState();
      const id = params.projectId || global.activeProjectId;
      if (!id) {
        return {
          content: [{ type: "text", text: JSON.stringify({ error: "No active project" }) }],
        };
      }

      const state = await stateManager.getProjectState(id);
      if (!state) {
        return {
          content: [{ type: "text", text: JSON.stringify({ error: `Project not found: ${id}` }) }],
        };
      }

      const updates: Partial<typeof state> = {};

      if (params.phase) updates.phase = params.phase as any;
      if (params.lastSkill) updates.lastSkill = params.lastSkill;
      if (params.currentTrack) updates.currentTrack = params.currentTrack;

      if (params.addTrack) {
        state.tracks.push({
          id: params.addTrack.id,
          name: params.addTrack.name,
          status: "pending",
          dependencies: params.addTrack.dependencies || [],
          promptFile: null,
        });
        updates.tracks = state.tracks;
      }

      if (params.addDecision) {
        state.decisions.push({
          date: new Date().toISOString().split("T")[0],
          topic: params.addDecision.topic,
          file: params.addDecision.file,
        });
        updates.decisions = state.decisions;
      }

      if (params.addSpec) {
        state.specs.push({
          version: params.addSpec.version,
          file: params.addSpec.file,
        });
        updates.specs = state.specs;
      }

      await stateManager.updateProjectState(id, updates);

      if (params.lastSkill) {
        await stateManager.addActivity(id, `skill:${params.lastSkill}`, `${params.lastSkill} completed`);
      }

      return {
        content: [{ type: "text", text: JSON.stringify({ updated: true, phase: params.phase || state.phase }) }],
      };
    },
  });
}
```

### 3.6 Plugin Entry — Detailed Design

```typescript
// index.ts

import type { PluginAPI } from "openclaw/plugin-sdk";
import { registerDojoCommands } from "./src/commands/router";
import { registerOrchestrationTools } from "./src/orchestration/tool-registry";
import { initStateManager } from "./src/state/manager";

export default {
  id: "dojo-genesis",
  name: "Dojo Genesis",
  slotType: "tool",

  configSchema: {
    type: "object" as const,
    properties: {
      projectsDir: {
        type: "string" as const,
        default: "dojo-genesis",
        description: "State directory (relative to ~/.openclaw/)",
      },
    },
  },

  register(api: PluginAPI) {
    // Initialize state manager with resolved config dir
    const configDir = api.deps.configDir; // ~/.openclaw/
    initStateManager(configDir);

    // Register /dojo command system
    registerDojoCommands(api);

    // Register orchestration tools (visible to agent)
    registerOrchestrationTools(api);

    // Register event-driven hooks
    api.registerHook("on-skill-complete", async (event) => {
      const { onSkillComplete } = await import("./src/hooks/on-skill-complete");
      return onSkillComplete(event);
    });

    api.registerHook("on-phase-change", async (event) => {
      const { onPhaseChange } = await import("./src/hooks/on-phase-change");
      return onPhaseChange(event);
    });

    api.logger.info("Dojo Genesis plugin initialized");
  },
};
```

### 3.7 Plugin Hooks — Detailed Design

```typescript
// src/hooks/on-skill-complete.ts

import { stateManager } from "../state/manager";

interface SkillCompleteEvent {
  skillName: string;
  result: string;
  context: Record<string, unknown>;
}

const SKILL_TO_OUTPUT_DIR: Record<string, string> = {
  "strategic-scout": "scouts",
  "release-specification": "specs",
  "parallel-tracks": "tracks",
  "implementation-prompt": "prompts",
  "retrospective": "retros",
};

const SKILL_TO_PHASE: Record<string, string> = {
  "strategic-scout": "scouting",
  "release-specification": "specifying",
  "parallel-tracks": "decomposing",
  "implementation-prompt": "commissioning",
  "retrospective": "retrospective",
};

export async function onSkillComplete(event: SkillCompleteEvent): Promise<void> {
  const projectId = event.context.dojoProject as string | undefined;
  if (!projectId) return; // Standalone mode — no action

  const phase = SKILL_TO_PHASE[event.skillName];
  if (phase) {
    await stateManager.updateProjectState(projectId, {
      phase: phase as any,
      lastSkill: event.skillName,
    });
  }

  await stateManager.addActivity(
    projectId,
    `skill:${event.skillName}`,
    `${event.skillName} completed`,
  );
}
```

```typescript
// src/hooks/on-phase-change.ts

import { stateManager } from "../state/manager";
import { writeTextFile } from "../utils/file-ops";

interface PhaseChangeEvent {
  projectId: string;
  fromPhase: string;
  toPhase: string;
}

export async function onPhaseChange(event: PhaseChangeEvent): Promise<void> {
  const { projectId, toPhase } = event;

  // Update PROJECT.md header
  const basePath = stateManager["basePath"];
  const projectMdPath = `${basePath}/projects/${projectId}/PROJECT.md`;

  try {
    const { promises: fs } = await import("fs");
    let content = await fs.readFile(projectMdPath, "utf-8");
    content = content.replace(/\*\*Phase:\*\* .+/, `**Phase:** ${toPhase}`);
    const logEntry = `- ${new Date().toISOString().split("T")[0]} — Phase changed to ${toPhase}\n`;
    content = content.replace(/(## Activity Log\n\n)/, `$1${logEntry}`);
    await writeTextFile(projectMdPath, content);
  } catch {
    // PROJECT.md may not exist yet — not critical
  }
}
```

### 3.8 Performance Considerations

**Auto-reply commands (init, switch, status, list, archive):**
- Target: < 50ms per command. These are file reads + JSON parse + string formatting. No network, no AI.
- Bottleneck: first read of global-state.json (cold cache). Subsequent reads use write-through cache.
- With 100 projects in global state: JSON parse ~2ms, array scan ~1ms. Well within budget.

**Orchestration tools (dojo_get_context, dojo_save_artifact, dojo_update_state):**
- Target: < 100ms per tool call. These involve file I/O.
- `dojo_save_artifact` uses atomic write (write to `.tmp`, then `rename`). On ext4/APFS, rename is ~1ms.
- Write-through cache means `dojo_get_context` rarely hits disk after the first call in a session.

**Memory footprint:**
- DojoStateManager caches global state (~1KB) + project states (~2KB each). With 10 active projects: ~21KB.
- Activity log capped at 50 entries per project. No unbounded growth.

**Disk usage:**
- Per project: state.json (~3KB) + PROJECT.md (~1KB) + artifacts (~variable). A typical project with 5 artifacts: ~50KB.
- Global state: ~5KB for 100 projects.

**Benchmark targets (added to Integration test suite):**
- `handleInit`: < 30ms (create dirs + write 3 files)
- `handleStatus`: < 10ms (cache hit path)
- `dojo_save_artifact`: < 50ms (atomic write)
- Full 6-phase workflow: < 2s total for all state operations (excluding agent turns)

### 3.9 SKILL.md Orchestration Section — Template

Every ported skill includes this section at the bottom. This is the contract between the skill and the orchestration engine:

```markdown
---

## Dojo Genesis Integration

This skill supports dual-mode operation:

**Standalone mode (no project):**
Skip this section. Output your results directly in chat.

**Orchestration mode (project active):**

1. **Check context:** Call `dojo_get_context` at the start. If `active: true`, you are in orchestration mode.
2. **Use prior context:** The response includes `phase`, `tracks`, `decisions`, and `recentActivity`. Reference these to maintain continuity with the project's history.
3. **Save your output:** When complete, call `dojo_save_artifact` with:
   - `outputDir`: "{OUTPUT_DIR}"
   - `filename`: "{FILENAME_PATTERN}"
   - `content`: Your full markdown output
4. **Update state:** Call `dojo_update_state` with:
   - `phase`: "{NEXT_PHASE}"
   - `lastSkill`: "{SKILL_NAME}"

**Detection rule:** If `dojo_get_context` returns `{ active: false }`, proceed in standalone mode. Do not call `dojo_save_artifact` or `dojo_update_state`.
```

---

## 4. Implementation Plan

### 4.1 Track Structure

**Track 0** (Foundation) is a prerequisite for all other tracks. **Tracks A and B** run in parallel. **Track C** depends on Track B (needs the orchestration section template). Integration depends on all tracks.

**Dependency DAG:**

```
                    ┌─────────────────┐
                    │  Track 0        │
                    │  Foundation     │
                    │  (3-4 days)     │
                    └──┬──────┬───┬──┘
                       │      │   │
              ┌────────┘      │   └────────┐
              ▼               │            ▼
   ┌──────────────────┐      │   ┌──────────────────┐
   │  Track A          │      │   │  Track B          │
   │  Commands + Chat  │      │   │  Orchestration    │
   │  (4-5 days)       │      │   │  (4-5 days)       │
   └────────┬─────────┘      │   └────────┬─────────┘
            │                 │            │
            │                 │   ┌────────┘
            │                 │   ▼
            │                 │  ┌──────────────────┐
            │                 │  │  Track C          │
            │                 │  │  Skill Migration  │
            │                 │  │  (5-6 days)       │
            │                 │  └────────┬─────────┘
            │                 │           │
            └────────┬────────┴───────────┘
                     ▼
          ┌──────────────────────┐
          │  Integration & QA    │
          │  (3-4 days)          │
          └──────────────────────┘

Total elapsed: ~12-15 days (Track 0 + max(A,B) + C + Integration)
              With A||B parallelism, saves 4-5 days vs sequential.
```

**Phase transition state machine:**

```
initialized ──→ scouting ──→ specifying ──→ decomposing ──→ commissioning ──→ implementing ──→ retrospective
     │              │            │              │                │                │               │
  /dojo init    /dojo scout  /dojo spec    /dojo tracks    /dojo commission   (external)     /dojo retro
                                                                                                │
                                                                                    ┌───────────┘
                                                                                    ▼
                                                                              (cycle back to
                                                                               initialized or
                                                                               scouting)
```

### 4.2 Track 0: Plugin Foundation

**Duration:** 3-4 days
**Dependencies:** None
**Deliverables:** Compilable plugin scaffold with types, state manager, utilities, and test infrastructure

**Tasks:**

- [ ] Create `package.json` with `openclaw.extensions`, `peerDependencies`, devDependencies (typescript, vitest)
- [ ] Create `tsconfig.json` targeting ES2022, module NodeNext
- [ ] Create `index.ts` plugin entry point (register function skeleton)
- [ ] Implement `src/state/types.ts` — all TypeScript interfaces (GlobalState, ProjectState, Track, etc.)
- [ ] Implement `src/state/manager.ts` — DojoStateManager with write-through cache
- [ ] Implement `src/state/migrations.ts` — Schema version check (stub for v1.0.0, real for v1.1.0)
- [ ] Implement `src/utils/file-ops.ts` — readJsonFile, writeJsonFile, writeTextFile, ensureDir, fileExists
- [ ] Implement `src/utils/validation.ts` — validateProjectName, sanitizeFilename, validateOutputDir
- [ ] Implement `src/utils/markdown.ts` — markdown helpers for generating PROJECT.md templates
- [ ] Implement `src/ui/chat-formatter.ts` — formatPhase, formatDate, formatTrackTable, formatProjectList
- [ ] Create test infrastructure: `vitest.config.ts`, test helpers (temp directory factory, state manager mock)
- [ ] Write unit tests for state manager (init, read, write, cache invalidation)
- [ ] Write unit tests for validation (valid names, invalid names, path traversal attempts)
- [ ] Write unit tests for file-ops (atomic write, ENOENT handling, ensureDir)

**Success criteria:** `npm run test` passes. State manager can create, read, update global and project state. All types compile without errors. Temp directory tests clean up after themselves.

### 4.3 Track A: Command System + Chat UI

**Duration:** 4-5 days
**Dependencies:** Track 0
**Deliverables:** All 10 `/dojo` subcommands working with formatted chat output

**Tasks:**

- [ ] Implement `src/commands/router.ts` — registerDojoCommands with full dispatch table
- [ ] Implement `src/commands/init.ts` — create project, directories, PROJECT.md, decisions.md, state.json
- [ ] Implement `src/commands/switch.ts` — validate project exists, set active, return confirmation
- [ ] Implement `src/commands/status.ts` — read state, format phase/tracks/activity/next action
- [ ] Implement `src/commands/list.ts` — list projects with phase, last active, active indicator, --all flag
- [ ] Implement `src/commands/archive.ts` — set archived flag, clear active if needed, return confirmation
- [ ] Implement `@project-name` parsing in resolveTargetProject
- [ ] Implement help text output for `/dojo` and `/dojo help`
- [ ] Write unit tests for each command handler (happy path, error cases)
- [ ] Write integration test: init -> status -> list -> switch -> status -> archive -> list
- [ ] Verify all chat output renders correctly in markdown (tables, bold, code blocks)

**Success criteria:** All 10 subcommands return correctly formatted markdown. `resolveTargetProject` handles `@override` and active project fallback. Error messages are clear and actionable. Integration test passes the full lifecycle.

### 4.4 Track B: Orchestration Engine

**Duration:** 4-5 days
**Dependencies:** Track 0
**Deliverables:** 3 registered tools + 2 hooks

**Tasks:**

- [ ] Implement `src/orchestration/tool-registry.ts` — registerOrchestrationTools with all 3 tools
- [ ] Implement `dojo_get_context` — return full project context or `{ active: false }`
- [ ] Implement `dojo_save_artifact` — validate outputDir, sanitize filename, write file, record in state
- [ ] Implement `dojo_update_state` — update phase, lastSkill, tracks, decisions, specs
- [ ] Implement `src/hooks/on-skill-complete.ts` — phase advancement, activity logging
- [ ] Implement `src/hooks/on-phase-change.ts` — PROJECT.md update
- [ ] Create `hooks/on-skill-complete/HOOK.md` — OpenClaw hook manifest
- [ ] Create `hooks/on-project-phase-change/HOOK.md` — OpenClaw hook manifest
- [ ] Wire hooks into `index.ts` register function
- [ ] Write unit tests for each tool (valid inputs, missing project, invalid outputDir)
- [ ] Write unit tests for hooks (standalone mode skip, orchestration mode fire)
- [ ] Write integration test: tool calls sequence (get_context -> save_artifact -> update_state)

**Success criteria:** All 3 tools registered and callable. `dojo_save_artifact` creates files atomically in the correct directory. `dojo_update_state` updates state and cache consistently. Hooks fire correctly in orchestration mode and skip silently in standalone mode.

### 4.5 Track C: Skill Migration (8 Core Skills)

**Duration:** 5-6 days
**Dependencies:** Track B (needs orchestration section template)
**Deliverables:** 8 SKILL.md files with Dojo Genesis Integration sections

**Skills to port:**

| # | Skill | Category | Output Dir | Phase On Complete |
|---|-------|----------|------------|-------------------|
| 1 | strategic-scout | STRATEGIZE | scouts | scouting |
| 2 | release-specification | SPECIFY | specs | specifying |
| 3 | parallel-tracks | SPECIFY | tracks | decomposing |
| 4 | implementation-prompt | SPECIFY | prompts | commissioning |
| 5 | retrospective | LEARN | retros | retrospective |
| 6 | context-ingestion | ORCHESTRATE | artifacts | (no phase change) |
| 7 | pre-implementation-checklist | SPECIFY | artifacts | (no phase change) |
| 8 | handoff-protocol | ORCHESTRATE | artifacts | (no phase change) |

**Tasks per skill:**

- [ ] Copy existing SKILL.md from the Dojo Genesis skill ecosystem
- [ ] Add OpenClaw-compatible frontmatter (name, description, metadata.openclaw.emoji, metadata.openclaw.dojo)
- [ ] Add "Dojo Genesis Integration" section using the template from Section 3.8
- [ ] Customize the integration section with correct outputDir, filename pattern, and next phase
- [ ] Validate SKILL.md structure with `openclaw skill validate`

**Additional tasks:**

- [ ] Create a SKILL.md template generator script (optional, for consistency)
- [ ] Write validation test: each SKILL.md parses correctly, frontmatter is valid
- [ ] Write content test: each SKILL.md contains the Dojo Genesis Integration section
- [ ] Manual review: read through each skill's orchestration section for correctness

**Success criteria:** All 8 skills pass `openclaw skill validate`. Each contains a correct orchestration section that references the right tools, output directory, and phase. Skills work in standalone mode (no project) and orchestration mode (with project context).

### 4.6 Integration and QA

**Duration:** 3-4 days
**Dependencies:** Tracks A, B, C
**Deliverables:** E2E tests passing, README, plugin ready for publishing

**Tasks:**

- [ ] Write E2E test: full workflow — init -> scout -> spec -> tracks -> commission -> retro
- [ ] Verify file system state after full workflow (all directories, all files, state.json correctness)
- [ ] Test dual-mode: run each core skill without a project (standalone), verify no state side effects
- [ ] Test error handling: invalid project names, missing projects, disk full simulation
- [ ] Test multi-project: create 2 projects, switch between them, verify isolation
- [ ] Test archive: archive a project, verify it disappears from list, verify files remain on disk
- [ ] Run `openclaw skill validate` on all 8 skills
- [ ] Security review: path traversal attempts, oversized inputs, special characters
- [ ] Write README.md (installation, quickstart, command reference, configuration)
- [ ] Write CHANGELOG.md (v1.0.0 initial release notes)
- [ ] Final `npm pack` dry run — verify package contents

**Success criteria:** E2E test passes the full 6-phase workflow. Dual-mode works for all skills. No path traversal possible. README is clear and complete. Package is publishable.

### 4.3 Dependencies and Prerequisites

**Required before starting:**

- OpenClaw development environment (Node.js 18+, OpenClaw installed locally)
- Access to OpenClaw Plugin SDK types (`openclaw/plugin-sdk`)
- Existing SKILL.md files for the 8 core skills (from Dojo Genesis skill ecosystem)

**Parallel work:**

- Track A (Commands) and Track B (Orchestration) are fully independent after Track 0
- Track C can begin skill content porting during Track A/B, deferring orchestration section finalization until Track B completes

**Blocking dependencies:**

- Track 0 blocks everything
- Track B blocks Track C's orchestration section writing
- All tracks block Integration

### 4.4 Testing Strategy

**Unit Tests (per track):**

- State manager: create, read, update, cache invalidation, concurrent-safety (single-message model)
- Validation: valid inputs, invalid inputs, edge cases (empty string, max length, unicode)
- Commands: each handler with mocked state manager
- Tools: each tool with mocked state manager and file system
- Hooks: fire/skip logic based on context

**Integration Tests:**

- Command lifecycle: init -> status -> list -> switch -> archive
- Tool chain: get_context -> save_artifact -> update_state
- Full workflow: init -> (tool calls simulating skill execution) -> verify state and files

**E2E Tests:**

- Full 6-phase workflow with real file system operations
- Multi-project isolation
- Dual-mode skill execution

**Performance Tests (benchmarks):**

- `handleInit` latency: < 30ms (create dirs + write 3 files)
- `handleStatus` latency: < 10ms (cache hit path)
- `dojo_save_artifact` latency: < 50ms (atomic write)
- Full 6-phase state operations: < 2s total
- Memory: DojoStateManager < 100KB with 50 projects cached

**Target:** 90%+ line coverage on `src/`. All tests pass with `vitest run`.

### 4.5 Manual QA Scenarios

**Happy path — full workflow walkthrough:**

1. `openclaw plugins install @openclaw/dojo-genesis` — plugin installs without errors
2. `/dojo init my-app --desc "Mobile redesign project"` — project created, confirmation in chat
3. `/dojo status` — shows phase: initialized, next action suggestion
4. `/dojo list` — shows `my-app` with active indicator
5. `/dojo scout "native vs PWA"` — agent runs strategic scout, output saved to `scouts/`
6. `/dojo status` — shows phase: scouting, recent activity includes scout
7. `/dojo spec "mobile-redesign"` — agent runs specification, output saved to `specs/`
8. `/dojo tracks` — agent decomposes into parallel tracks, saved to `tracks/`
9. `/dojo commission` — agent generates implementation prompts, saved to `prompts/`
10. `/dojo retro` — agent runs retrospective, saved to `retros/`
11. Verify all files exist in `~/.openclaw/dojo-genesis/projects/my-app/`

**Error path scenarios:**

- `/dojo init` (no name) — returns validation error
- `/dojo init MY_APP` (uppercase) — returns naming convention error
- `/dojo init ../../etc/passwd` (path traversal) — returns validation error
- `/dojo switch nonexistent` — returns "project not found" error
- `/dojo scout "tension"` (no project) — returns "no active project" error
- `/dojo archive my-app` then `/dojo status` — returns "no active project"

**Multi-project scenario:**

- `/dojo init project-a` → `/dojo init project-b` → `/dojo list` (both visible, project-b active)
- `/dojo scout @project-a "tension"` — targets project-a despite project-b being active
- `/dojo switch project-a` → `/dojo status` — confirms project-a is now active

**OS compatibility checklist:**

- [ ] macOS (native) — file permissions, path separators, atomic rename
- [ ] Linux (Ubuntu 22+) — file permissions, case sensitivity
- [ ] Windows (via WSL2) — path length limits, special characters

---

## 5. Risk Assessment and Mitigation

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| OpenClaw Plugin SDK API changes before ship | Medium | High | Pin to SDK version in peerDependencies. Test against specific OpenClaw release. Monitor OpenClaw changelog. |
| `shouldContinue` + `updatedCtx` pattern behaves differently than documented | Low | High | Build a minimal test plugin that validates the pattern before writing all commands. Track 0 includes this validation. |
| 44 skills overwhelm system prompt token budget | Low | Medium | Ship 8 core skills in v1.0.0. Document skill profiles (Full/Core/Minimal) in README. Users can disable via `enabled: false`. |
| File system permissions issues on different OS | Medium | Medium | Use `~/.openclaw/` which OpenClaw already manages. Test on macOS, Linux. Windows via WSL. |
| Hook event names differ from documented pattern | Medium | Medium | Test hook registration in Track B before depending on it in other tracks. Fallback: agent-mediated saves via tool calls (already the primary path). |
| A2UI v0.8 has breaking changes before v1.1.0 Canvas work | Low | Low | Canvas deferred to v1.1.0. Architecture specified but not built. No v1.0.0 risk. |

## 6. Rollback and Contingency

**Plugin uninstall:** `openclaw plugins uninstall @openclaw/dojo-genesis` cleanly removes the plugin. State files at `~/.openclaw/dojo-genesis/` persist (user data, not deleted on uninstall).

**Graceful degradation:** If hooks don't fire, the agent-mediated tool call path (skills calling `dojo_save_artifact` and `dojo_update_state` directly) serves as the primary mechanism. Hooks are a convenience layer, not a requirement.

**Schema migrations:** `global-state.json` includes a `version` field. `src/state/migrations.ts` provides a migration path for future schema changes. v1.0.0 sets the baseline.

**Monitoring and observability:**

- **Structured logging:** All state mutations log via `api.logger.info` with context: `[dojo-genesis] {action} {projectId} {duration}ms`
- **Error logging:** All caught exceptions log via `api.logger.error` with stack traces. File I/O errors include the target path.
- **Activity log:** Each project's `activityLog` records the last 50 actions with timestamps. This serves as the user-facing audit trail.
- **PROJECT.md:** Human-readable activity trail updated on phase changes. This is the "dashboard" for users who browse the file system directly.
- **Debugging:** `dojo_get_context` returns full state including recent activity — agents can inspect state without file system access.
- **Health check:** `/dojo status` implicitly validates state file integrity. If `state.json` is corrupted, the error message directs the user to delete and reinitialize.

## 7. Documentation and Communication

**User-facing documentation:**

- [ ] README.md with installation, quickstart (5-minute tutorial), command reference, configuration
- [ ] CHANGELOG.md with v1.0.0 release notes
- [ ] Inline help via `/dojo help`

**Developer documentation:**

- [ ] ARCHITECTURE.md (already at v0.4.0 — update to v1.0.0 after shipping)
- [ ] CONTRIBUTING.md (for future contributors)
- [ ] Code comments on all exported functions

**Release notes template:**

```
## v1.0.0 — The Orchestration Engine

Initial release of Dojo Genesis for OpenClaw.

**Features:**
- /dojo commands for project lifecycle management
- 3 orchestration tools for project-aware skill execution
- 8 core skills with dual-mode operation
- Persistent file-based project state
- Markdown artifact generation (scouts, specs, prompts, retros)

**Installation:**
openclaw plugins install @openclaw/dojo-genesis
```

---

## 8. Appendices

### 8.1 Related Work

- **Dojo Genesis Desktop Shell (Tauri):** The original Dojo Genesis experience. v0.2.5 ships 57 endpoints and 5 parallel implementation tracks. The ClawHub plugin brings the same methodology to OpenClaw's broader reach.
- **OpenClaw Plugin Ecosystem:** 5,700+ skills on ClawHub. The plugin model (`openclaw.extensions`, `api.registerTool()`, hooks) is mature and well-documented.
- **Agentic Gateway (Go):** A separate project — the Go-based AI gateway runtime. Not directly related to this plugin, but shares the "Agentic Stack" vision (Runtime → Identity → Protocol → Behavioral → Surface).

### 8.2 Future Considerations (v1.1.0 and Beyond)

**v1.0.x — Skill Expansion:**
- Port remaining 36 skills in category batches (STRATEGIZE, REMEMBER, OBSERVE, LEARN, BUILD)
- Each batch is a patch release (v1.0.1, v1.0.2, etc.)

**v1.1.0 — Canvas UI:**
- A2UI project dashboard (phase indicator, track cards, recent decisions)
- A2UI track board (progress bars, dependency arrows)
- A2UI spec viewer (rendered markdown with navigation)
- Canvas availability detection and progressive enhancement

**v2.0.0 — Multi-User and Cloud:**
- Shared project state via file sync or cloud backend
- Permission model for team projects
- Conflict resolution for concurrent state updates

### 8.3 Resolved Architectural Questions

All 10 architectural questions (6 original + 4 UI) were resolved via iterative scouting. Full resolutions are documented in ARCHITECTURE.md v0.4.0, Sections XIV and XIII-B. Key decisions:

| # | Question | Resolution |
|---|----------|------------|
| Q1 | Command routing | `shouldContinue` flag, not null routing |
| Q2 | Context injection | Tool-pull primary (`dojo_get_context`), context-push supplementary (`updatedCtx`) |
| Q3 | Tool registration | `api.registerTool()` confirmed with allowlist visibility |
| Q4 | Skill versioning | Monolith at plugin version |
| Q5 | Prompt token budget | ~1,775 tokens acceptable; 3 skill profiles documented |
| Q6 | State caching | Singleton write-through; safe due to single-message processing |
| UI-1 | Canvas templating | A2UI declarative JSON (template structure, dynamic data) |
| UI-2 | Event handling | Canvas -> Gateway -> agent turn; agent mediates |
| UI-3 | Cross-channel Canvas | No; session-scoped, node-specific |
| UI-4 | Artifact format | Markdown throughout |

### 8.4 References

1. [ARCHITECTURE.md v0.4.0](../ARCHITECTURE.md) — Full architectural specification
2. [Strategic Scout: Gateway UI](../scouts/2026-02-12_strategic_scout_gateway_ui.md) — UI direction and three-surface model
3. [OpenClaw Plugin SDK](https://deepwiki.com/openclaw/openclaw/10.3-creating-custom-plugins) — Plugin registration API
4. [OpenClaw Command Reference](https://deepwiki.com/openclaw/openclaw/9.1-command-reference) — `shouldContinue` pattern
5. [OpenClaw Tools and Skills](https://deepwiki.com/openclaw/openclaw/6-tools-and-skills) — Tool registration and visibility
6. [OpenClaw Skills System](https://deepwiki.com/openclaw/openclaw/6.3-skills-system) — SKILL.md format and loading
7. [A2UI Architecture](https://ppaolo.substack.com/p/openclaw-system-architecture-overview) — Canvas declarative JSON
